import "server-only";import type { NextFetchRequestConfig } from "next/dist/server/web/spec-extension/request";import { appConfig } from "@/app-config";import type { CacheTag } from "./cache-tags";export class FetcherError extends Error {  constructor(    message: string,    readonly status: number,    readonly info?: unknown  ) {    super(message);    this.name = "FetcherError";  }}type BaseFetcherInit = Omit<RequestInit, "next"> & {  revalidate?: number;  tags?: CacheTag[];  next?: NextFetchRequestConfig;  parse?: "json" | "text" | "arrayBuffer";};const buildUrl = (input: string | URL): string => {  if (input instanceof URL) return input.toString();  if (input.startsWith("http://") || input.startsWith("https://")) {    return input;  }  return new URL(input, appConfig.urls.base).toString();};const normalizeTags = (tags: CacheTag[] = [], next?: NextFetchRequestConfig) => {  const set = new Set<CacheTag>();  if (next?.tags) {    for (const tag of next.tags) {      set.add(tag as CacheTag);    }  }  for (const tag of tags) {    set.add(tag);  }  return Array.from(set);};export async function fetcher<TResponse = unknown>(  input: string | URL,  init: BaseFetcherInit = {}): Promise<TResponse> {  const {    revalidate,    tags,    headers,    cache: cacheStrategy,    credentials = "include",    parse = "json",    next,    ...rest  } = init;  const url = buildUrl(input);  const nextConfig: NextFetchRequestConfig = {    revalidate: revalidate ?? next?.revalidate ?? appConfig.cache.defaultRevalidate,    tags: normalizeTags(tags, next),  };  const response = await fetch(url, {    ...rest,    headers: {      Accept: "application/json",      "Content-Type": "application/json",      ...headers,    },    cache: cacheStrategy,    credentials,    next: nextConfig,  });  if (!response.ok) {    let info: unknown;    try {      info = await response.clone().json();    } catch {      info = await response.text();    }    throw new FetcherError(      `Request to ${url} failed with status ${response.status}`,      response.status,      info    );  }  if (response.status === 204) {    return undefined as TResponse;  }  if (parse === "text") {    return (await response.text()) as TResponse;  }  if (parse === "arrayBuffer") {    return (await response.arrayBuffer()) as TResponse;  }  return (await response.json()) as TResponse;}export function withRevalidate<TResponse = unknown>(  input: string | URL,  init: BaseFetcherInit & { revalidate: number }) {  return fetcher<TResponse>(input, init);}export function withNoStore<TResponse = unknown>(  input: string | URL,  init: BaseFetcherInit = {}) {  return fetcher<TResponse>(input, { ...init, cache: "no-store", revalidate: 0 });}